"""
SQLAlchemy ORM models for database persistence.

Defines database schema for alerts, outcomes, whales, and their associations.
"""

from datetime import datetime, timezone
from typing import Optional, List, Dict, Any
import json

from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy import String, Integer, Float, Boolean, DateTime, JSON, Text, ForeignKey, Index


class Base(DeclarativeBase):
    """Base class for all database models"""
    pass


class Alert(Base):
    """
    Alert records from detection algorithms.

    Stores all alerts generated by volume, whale, price, and coordination detectors.
    """
    __tablename__ = "alerts"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    market_id: Mapped[str] = mapped_column(String(100), index=True, nullable=False)
    market_question: Mapped[str] = mapped_column(Text, nullable=False)
    alert_type: Mapped[str] = mapped_column(String(50), nullable=False)  # AlertType enum value
    severity: Mapped[str] = mapped_column(String(20), nullable=False)  # AlertSeverity enum value
    timestamp: Mapped[datetime] = mapped_column(DateTime(timezone=True), index=True, nullable=False)
    analysis_json: Mapped[dict] = mapped_column(JSON, nullable=False)  # Full detection analysis
    confidence_score: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=lambda: datetime.now(timezone.utc)
    )

    # Relationships
    outcome: Mapped[Optional["AlertOutcome"]] = relationship(
        "AlertOutcome",
        back_populates="alert",
        uselist=False,
        cascade="all, delete-orphan"
    )
    whale_associations: Mapped[List["WhaleAlertAssociation"]] = relationship(
        "WhaleAlertAssociation",
        back_populates="alert",
        cascade="all, delete-orphan"
    )

    # Indexes for common queries
    __table_args__ = (
        Index('idx_alert_market_time', 'market_id', 'timestamp'),
        Index('idx_alert_severity_time', 'severity', 'timestamp'),
        Index('idx_alert_type_time', 'alert_type', 'timestamp'),
    )

    def __repr__(self) -> str:
        return (
            f"<Alert(id={self.id}, type={self.alert_type}, "
            f"severity={self.severity}, market={self.market_id[:10]}...)>"
        )

    def to_dict(self) -> Dict[str, Any]:
        """Serialize alert to dictionary"""
        return {
            'id': self.id,
            'market_id': self.market_id,
            'market_question': self.market_question,
            'alert_type': self.alert_type,
            'severity': self.severity,
            'timestamp': self.timestamp.isoformat(),
            'analysis': self.analysis_json,
            'confidence_score': self.confidence_score,
            'created_at': self.created_at.isoformat(),
        }


class AlertOutcome(Base):
    """
    Outcome tracking for alerts.

    Tracks price movements and market resolutions to measure alert effectiveness.
    One outcome per alert (1:1 relationship).
    """
    __tablename__ = "alert_outcomes"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    alert_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey('alerts.id', ondelete='CASCADE'),
        unique=True,
        nullable=False
    )

    # Price tracking
    price_at_alert: Mapped[float] = mapped_column(Float, nullable=False)
    price_1h_after: Mapped[Optional[float]] = mapped_column(Float)
    price_4h_after: Mapped[Optional[float]] = mapped_column(Float)
    price_24h_after: Mapped[Optional[float]] = mapped_column(Float)

    # Calculated price changes
    price_change_1h_pct: Mapped[Optional[float]] = mapped_column(Float)
    price_change_4h_pct: Mapped[Optional[float]] = mapped_column(Float)
    price_change_24h_pct: Mapped[Optional[float]] = mapped_column(Float)

    # Market resolution
    market_resolved: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    market_resolution: Mapped[Optional[str]] = mapped_column(String(20))  # YES/NO/DRAW/CANCELLED
    resolution_timestamp: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))

    # Prediction tracking
    predicted_direction: Mapped[str] = mapped_column(String(10), nullable=False)  # BUY/SELL
    was_profitable: Mapped[Optional[bool]] = mapped_column(Boolean)  # Calculated field

    # Metadata
    last_updated: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc)
    )

    # Relationships
    alert: Mapped["Alert"] = relationship("Alert", back_populates="outcome")

    def __repr__(self) -> str:
        return (
            f"<AlertOutcome(id={self.id}, alert_id={self.alert_id}, "
            f"resolved={self.market_resolved}, profitable={self.was_profitable})>"
        )

    def calculate_profitability(self) -> None:
        """
        Calculate if alert was profitable based on price movement and prediction.

        Sets was_profitable field based on whether price moved in predicted direction.
        """
        if self.price_24h_after is None or self.predicted_direction is None:
            self.was_profitable = None
            return

        price_change = self.price_24h_after - self.price_at_alert

        if self.predicted_direction == 'BUY':
            # Profitable if price went up
            self.was_profitable = price_change > 0
        elif self.predicted_direction == 'SELL':
            # Profitable if price went down
            self.was_profitable = price_change < 0
        else:
            self.was_profitable = None

    def to_dict(self) -> Dict[str, Any]:
        """Serialize outcome to dictionary"""
        return {
            'id': self.id,
            'alert_id': self.alert_id,
            'price_at_alert': self.price_at_alert,
            'price_1h_after': self.price_1h_after,
            'price_4h_after': self.price_4h_after,
            'price_24h_after': self.price_24h_after,
            'price_change_1h_pct': self.price_change_1h_pct,
            'price_change_4h_pct': self.price_change_4h_pct,
            'price_change_24h_pct': self.price_change_24h_pct,
            'market_resolved': self.market_resolved,
            'market_resolution': self.market_resolution,
            'resolution_timestamp': self.resolution_timestamp.isoformat() if self.resolution_timestamp else None,
            'predicted_direction': self.predicted_direction,
            'was_profitable': self.was_profitable,
            'last_updated': self.last_updated.isoformat(),
        }


class WhaleAddress(Base):
    """
    Tracked whale wallet addresses.

    Stores whale trading activity, market maker classification, and metrics.
    """
    __tablename__ = "whale_addresses"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    address: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)

    # Activity tracking
    first_seen: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)
    last_seen: Mapped[datetime] = mapped_column(DateTime(timezone=True), nullable=False)

    # Volume metrics
    total_volume_usd: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    trade_count: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    buy_volume_usd: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    sell_volume_usd: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)

    # Market maker classification
    is_market_maker: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    market_maker_score: Mapped[int] = mapped_column(Integer, default=0, nullable=False)  # 0-100

    # Fresh wallet tracking
    is_fresh_wallet: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    verified_fresh: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)  # API verification completed

    # Flexible data storage
    tags_json: Mapped[List[str]] = mapped_column(JSON, nullable=False, default=list)  # ["coordination", "volume_spike", etc.]
    metrics_json: Mapped[dict] = mapped_column(JSON, nullable=False, default=dict)  # avg_trade_size, coordination_score, etc.
    markets_traded_json: Mapped[List[str]] = mapped_column(JSON, nullable=False, default=list)  # List of market IDs

    # Metadata
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        default=lambda: datetime.now(timezone.utc),
        onupdate=lambda: datetime.now(timezone.utc)
    )

    # Relationships
    alert_associations: Mapped[List["WhaleAlertAssociation"]] = relationship(
        "WhaleAlertAssociation",
        back_populates="whale",
        cascade="all, delete-orphan"
    )

    # Index for MM filtering
    __table_args__ = (
        Index('idx_whale_mm_volume', 'is_market_maker', 'total_volume_usd'),
    )

    def __repr__(self) -> str:
        return (
            f"<WhaleAddress(id={self.id}, address={self.address[:10]}..., "
            f"volume=${self.total_volume_usd:,.0f}, is_mm={self.is_market_maker})>"
        )

    @property
    def tags(self) -> List[str]:
        """Get tags list (convenience property)"""
        return self.tags_json if self.tags_json else []

    @tags.setter
    def tags(self, value: List[str]) -> None:
        """Set tags list"""
        self.tags_json = value

    @property
    def metrics(self) -> dict:
        """Get metrics dict (convenience property)"""
        return self.metrics_json if self.metrics_json else {}

    @metrics.setter
    def metrics(self, value: dict) -> None:
        """Set metrics dict"""
        self.metrics_json = value

    @property
    def markets_traded(self) -> List[str]:
        """Get markets traded list (convenience property)"""
        return self.markets_traded_json if self.markets_traded_json else []

    @markets_traded.setter
    def markets_traded(self, value: List[str]) -> None:
        """Set markets traded list"""
        self.markets_traded_json = value

    def to_dict(self) -> Dict[str, Any]:
        """Serialize whale to dictionary"""
        return {
            'id': self.id,
            'address': self.address,
            'first_seen': self.first_seen.isoformat(),
            'last_seen': self.last_seen.isoformat(),
            'total_volume_usd': self.total_volume_usd,
            'trade_count': self.trade_count,
            'buy_volume_usd': self.buy_volume_usd,
            'sell_volume_usd': self.sell_volume_usd,
            'is_market_maker': self.is_market_maker,
            'market_maker_score': self.market_maker_score,
            'tags': self.tags,
            'metrics': self.metrics,
            'markets_traded': self.markets_traded,
            'updated_at': self.updated_at.isoformat(),
        }


class WhaleAlertAssociation(Base):
    """
    Many-to-many association between whales and alerts.

    Links whale addresses to specific alerts they participated in.
    """
    __tablename__ = "whale_alert_associations"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    whale_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey('whale_addresses.id', ondelete='CASCADE'),
        nullable=False
    )
    alert_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey('alerts.id', ondelete='CASCADE'),
        nullable=False
    )

    # Association metadata
    whale_volume_in_alert: Mapped[float] = mapped_column(Float, nullable=False)
    whale_role: Mapped[str] = mapped_column(String(20), nullable=False)  # PRIMARY_ACTOR, COORDINATOR, PARTICIPANT

    # Relationships
    whale: Mapped["WhaleAddress"] = relationship("WhaleAddress", back_populates="alert_associations")
    alert: Mapped["Alert"] = relationship("Alert", back_populates="whale_associations")

    # Ensure unique whale-alert pairs
    __table_args__ = (
        Index('idx_unique_whale_alert', 'whale_id', 'alert_id', unique=True),
    )

    def __repr__(self) -> str:
        return (
            f"<WhaleAlertAssociation(whale_id={self.whale_id}, alert_id={self.alert_id}, "
            f"role={self.whale_role}, volume=${self.whale_volume_in_alert:,.0f})>"
        )

    def to_dict(self) -> Dict[str, Any]:
        """Serialize association to dictionary"""
        return {
            'id': self.id,
            'whale_id': self.whale_id,
            'alert_id': self.alert_id,
            'whale_volume_in_alert': self.whale_volume_in_alert,
            'whale_role': self.whale_role,
        }
